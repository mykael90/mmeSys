import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { REHYDRATE } from 'redux-persist';
import type { RootState } from '..';

import supabase from '../../services/supabaseClient';

type FormValues = {
  email: string;
  password: string;
};

export async function supabaseLogin(values: FormValues): Promise<any> {
  try {
    const { data, error } = await supabase.auth.signInWithPassword({
      email: values.email,
      password: values.password,
    });

    if (error) throw error;

    return { data, error };
  } catch (error) {
    console.log(error);
    return { error: 'Credenciais inválidas' };
  }
}
export async function supabaseOut(): Promise<any> {
  try {
    const { error } = await supabase.auth.signOut();

    if (error) {
      throw error;
    } else {
      return null;
    }
  } catch (error) {
    console.log(error);
    return { error };
  }
}

export interface AuthState {
  isLoggedIn: boolean;
  session: object;
  isLoading: boolean;
}

const initialState: AuthState = {
  isLoggedIn: false,
  session: {},
  isLoading: false,
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const loginRequest = createAsyncThunk(
  'auth/fetchAuth',
  async (payload: FormValues, { rejectWithValue }) => {
    const response = await supabaseLogin(payload);

    if (response.data) {
      return response.data;
    }
    return rejectWithValue(response.error);
  },
);

export const loginOut = createAsyncThunk('auth/AuthOut', async () => {
  await supabaseOut();
});

export const authSlice = createSlice({
  name: 'auth',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    increment: (_state) => {
      const state = _state;
      console.log(2, _state);
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes
      state.isLoading = false;
    },
    decrement: (_state) => {
      const state = _state;
      console.log(10, _state);
      state.isLoading = false;
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    incrementByAmount: (_state, action: PayloadAction<number>) => {
      console.log(3);
      const state = _state;
      state.isLoading = false;
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    setAmount: (_state, action: PayloadAction<number>) => {
      const state = _state;
      console.log(4, state);
      state.isLoading = false;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    console.log('always runs');

    builder.addCase(REHYDRATE, (_state) => {
      const state = _state;

      const data = JSON.parse(localStorage.getItem('sb-ejoryipjjcozqunyoxhz-auth-token') ?? '{}');

      if (Object.keys(data).length) {
        const expiresAt = new Date(data.expires_at * 1000);
        const dateNow = new Date();

        const isExpired = expiresAt < dateNow;

        if (isExpired) {
          console.log('sessão expirada, usuario desconectado, realizar novo login');
          const signOut = async () => {
            const { error } = await supabase.auth.signOut();
            console.log(error);
          };
          signOut();
          state.isLoggedIn = false;
          state.isLoading = false;
        } else {
          console.log('sessão válida');
          state.session = data;
          state.isLoggedIn = true;
          state.isLoading = false;
        }
      } else {
        console.log('sessão não localizada no store');
      }
    });

    builder
      .addCase(loginRequest.pending, (_state) => {
        const state = _state;
        console.log(5, _state);
        state.isLoading = true;
      })
      .addCase(loginRequest.fulfilled, (_state, action) => {
        const state = _state;
        console.log(6, _state, action);
        state.isLoggedIn = true;
        state.isLoading = false;
        state.session = action.payload.session;
      })
      .addCase(loginRequest.rejected, (_state) => {
        const state = _state;
        console.log(7, _state);
        state.isLoggedIn = false;
        state.isLoading = false;
      });

    builder
      .addCase(loginOut.pending, (_state) => {
        const state = _state;
        state.isLoading = true;
      })
      .addCase(loginOut.fulfilled, (_state) => {
        const state = _state;
        console.log(6, _state);
        state.isLoggedIn = false;
        state.isLoading = false;
        state.session = {};
      });
  },
});

export const { increment, decrement, incrementByAmount, setAmount } = authSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`

export const selectAuth = (state: RootState) => state.auth;

export default authSlice.reducer;
